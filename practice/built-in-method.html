<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      console.log(Math.pow(100, 1000000)); //Math.pow(base, exponent) 제곱구하기
      console.log(null + 1);
      console.log(null === undefined); // false
      console.log(null == undefined); // true
      console.log(typeof null); // object
      console.log(typeof undefined); // undefined
      console.log(eval('100 + 100')); //문자열로 된 것을 자바스크립트 코드로 변환함
      //아래는 각 진수에 맞는 숫자를 10진수로 다시 변환
      console.log(parseInt('100', 10)); //문자열이 있으면 이 것을 십진수로 고치시오
      console.log(parseInt('100', 16)); //문자열이 있으면 이 것을 16진수로 고치시오
      console.log(parseInt('100', 8)); //문자열이 있으면 이 것을 8진수로 고치시오
      console.log(parseInt('100', 2)); //문자열이 있으면 이 것을 이진수로 고치시오
      console.log(parseInt('100%abc', 10)); //어떤 문자열들을 slicing하지 않고 정수로만 출력할 때 사용!!!
      console.log(parseFloat('100.1000.123.abc!!.10.1%abc', 10)); //100.1 까지만 출력
      console.log(parseFloat('100,1,0,0,0,.12.abc!!10.1%abc', 10)); //100까지만 출력 (콤마 앞에서 컷)

      //Array(), Boolean(), Number(), String(), Object(), RegExp(), Map(), Set() -- Number()대신 parseInt() 사용할 것. Map()은 object이지만 더 일관성 있게 코딩 가능
      //  object접근은 아래와 같이 '.' 점 또는 [] 대괄호로 가능
      // ob.one
      // ob['one']
      // 하지만 위의 예시가 이와 같다면 -> ob.1 , ob[1] ob.1은 작동하지 않는다
      // Map(), Set()은 반복문 통하지 않고 특정 값을 가지고 있는지 has() 메소드로 확인 가능
      console.log('-----------------');
      let arr = [10, 2, 3, 22, 33, 100, 11];
      //이어 붙이는 것은 concat()
      let arrTwo = [12, 13];
      console.log(arr.concat(arrTwo)); //10, 2, 3, 22, 33, 100, 11, 12, 13] --리턴되는 값만 변환한 것임
      console.log(arr); //[10, 2, 3, 22, 33, 100, 11] --concat은 array를 바꾸지 않는다
      //   Stack 구조
      console.log(arr.pop()); //마지막 요소를 꺼내서 그 요소만 return
      console.log(arr); // pop으로 요소 제거된 나머지 배열
      console.log(arr.push(1000)); //배열의 전체 length를 반환
      console.log(arr);
      //   queue
      console.log(arr.shift()); //앞에서 꺼낸 요소를 return
      console.log(arr);
      // 관련하여 알면 좋은 메소드 : unshift() -- 값을 앞에서 넣는다
      console.log('-----------------');
      console.log(arr.length); //properties
      console.log(arrTwo.fill(100)); //어떤 값을 넣어서 초기화 시켜 줄 때 사용
      console.log(arrTwo);
      //반복문 돌지 않고 배열에서 30보다 큰 값을 호출하는 법
      console.log(arr.filter((x) => x > 30)); //true인 것만 출력, 여기서 x는 arr배열의 원소들
      //원소들이 숫자가 아닌 문자열인 경우는 아래
      console.log(arr.filter((x) => x.length > 10)); //문자열의 길이가 열 자리 이상인 것만 출력
      console.log('-----------------');
      //   행렬 구하기
      let arrThree = [1, 2, 3, [1, 2, 3, [10, 20]]];
      console.log(arrThree.flat()); //한꺼풀 벗겨냄
      console.log(arrThree.flat(2)); //두꺼풀 벗겨내서 1차원배열 만듬
      console.log(arr.includes(10)); //행렬의 10을 포함하고 있냐? -- boolean return
      console.log(arr);
      console.log(arr.includes(100)); //행렬의 10을 포함하고 //있냐? -- boolean return
      console.log(arr.join('-')); //2-3-22-33-100-1000 => '-'로 하나의 문자열로 합침
      function f(x) {
        return x ** 2; //x의 제곱을 반환
      }
      console.log(arr.map(f)); //
      // 이 map 메소드를 이용해서 문자열로 된 array 값들을 숫자로 바꿔줄 수 있음
      function f2(x) {
        return parseInt(x);
      }
      console.log(['1', '2', '3'].map(f2)); //[1, 2, 3]
      //위의 것을 arrow 함수로
      console.log(['1', '2', '3'].map((x) => parseInt(x)));
      console.log(arr.sort()); //sort()는 사전식 정렬!!!
      console.log(arr.reverse());
      // slice() 와 splice()
      console.log(arr.splice(2, 1, 'hello')); //요소를 삭제하거나 교체
      console.log(arr);
      console.log(arr.slice(3, 6)); // 요소를 인덱스 기준으로 잘라냄
      console.log(arr); //slice()는 원본 배열을 변경시키지 않는다
      console.log('-----------------');
      arr = [1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5];
      let s = new Set(arr); // 중복을 제거!!!
      console.log(s); // Set(5) {1, 2, 3, 4, 5}
      console.log(s.length); // undefined
      console.log(s.size); //set의 length를 구하고 싶을 때는 size()사용
      console.log(s.has(1)); //1을 가지고 있는지 확인 (filter()랑 비슷)
      console.log('-----------------');
      //set으로 교집합,합집합,차집합 구함
      let m = new Map();
      m.set('하나', 'one'); //param1: key, param2: value --param1에는 함수, obj, NaN도 들어갈 수 있음
      m.set('둘', 'two');
      m.set('셋', 'three');
      console.log(m);
      console.log(m.has('하나')); //true
      console.log(m.get('하나')); //one
      for (let [key, value] of m) {
        console.log(key);
        console.log(value);
      }
      for (let value of m) {
        console.log(value);
      }
      console.log('--------------------------');
      let str = 'abc abc de de abcde \n defg'; // \n 이스케이프 문자
      // \n (엔터효과)\t (탭효과) \v (스페이스바 효과)
      console.log(str);
      console.log(str.concat('hello world'));
      console.log(str);
      console.log(str.includes('fgh'));
      console.log(str.split(' ')); // 각각의 문자열로 나눠줌
      console.log(str.replace('abc', '!')); //abc를 !로 바꿈
      //-> ! abc de de abcde defg -- 뒤에 abc 는 안바뀜(정규표현식 사용해야함)
      //console.log(str.replace('abc', '!'));
      console.log(str.replace(/abc/g, '!')); // 슬래쉬로 감싸고 g를 붙이면 전역으로 교체함.
      //정규표현식에서 띄어쓰기를 언급할 때는 /  /g
      console.log(str.replace(/ /g, '-'));
      console.log(str.slice(3, 6)); //ab
      console.log(str.indexOf('abcde')); //첫 번째 만나는 'abcde'의 index를 반환
      console.log(str.length);
      let re = /abc/gi; // i는 대소문자 없이 찾아내라는 뜻. g 안붙이면 처음 만나는 abc만 적용됨
      console.log(str.match(re)); //match 안에는 정규표현식 들어감
      //->["abc", "abc", "abc"]
    </script>
  </body>
</html>
